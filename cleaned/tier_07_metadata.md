### tier\_07\_metadata.json5

json5  
Copy code  
{ // \====================================================================== // TIER 07 — Σ-FAMILY METADATA // Summation / Contraction Invariants // \====================================================================== "tier": 7, "family": "Sigma", "symbol": "Σ", "name": "Summation / Contraction Invariants", "version": "0.1.0", "status": "draft", "invariants": \[ { "id": "SIGMA\_INV\_INDEX\_PRESERVATION", "name": "Index-Preservation Invariant", "summary": "Contraction may only remove paired indices; remaining free indices must match pre/post tensor rank and ordering up to explicit schema.", "informal": "Σ may not create or destroy free indices. You can only sum over indices that appear in a valid contraction pair." }, { "id": "SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION", "name": "Polarity-Consistent Contraction Invariant", "summary": "Contraction over polarity-labeled indices must respect Θ routing and ΣΘ rules; illegal polarity mixes are forbidden unless an explicit operator mediates.", "informal": "You cannot secretly mix Θ+ and Θ− in the same contraction unless a polarity bridge operator is present." }, { "id": "SIGMA\_INV\_NULL\_MODE\_STABILITY", "name": "Null-Mode Stability Invariant", "summary": "Null components (semantic zero modes) remain null under Σ unless an explicit source term is present.", "informal": "Summing zeros cannot generate a nonzero semantic mode." } \], "dependencies": { "tiers\_required": \[0, 1, 2, 6, 8\], // primitives, Tri-Unity, ψ, Θ "operator\_families": \["Tri-Unity", "Theta", "Psi"\] }, "normal\_forms": { "sigma\_nf\_tag": "NF\_SIGMA", "description": "A Σ-normal form is a tensor or scalar whose indices, polarity channels, and null modes all satisfy the Σ-invariants and admit no further invariant-restoring rewrites." }, "textbook": { "chapter\_title": "Chapter 7 — Summation and Contraction Invariants (Σ)", "sections": \[ "7.1 Tensor Indices and Semantic Domains", "7.2 The Index-Preservation Invariant", "7.3 Polarity-Consistent Contraction and ΣΘ", "7.4 Null-Mode Stability and Semantic Zero", "7.5 Σ-Normal Form and Rewrite Systems", "7.6 Worked Examples and Regression Tests" \], "dual\_column\_mapping": { "physics\_side": \[ "Index bookkeeping in tensor calculus", "Charge / parity preserving contractions", "Zero-modes and conservation laws" \], "igsoa\_side": \[ "Domain tensor index discipline (Dᵢⱼₖ…)", "Θ-aware Σ-contractions over semantic polarity", "Semantic null modes and invariant-preserving rewrites" \] } } }  
---

### 2\. tier\_07\_operator\_pack.json5

json5  
Copy code  
{ // \====================================================================== // TIER 07 — Σ-OPERATOR PACK // Core Σ operators \+ invariant checkers // \====================================================================== "tier": 7, "family": "Sigma", "operator\_pack\_id": "T07\_SIGMA\_OPERATOR\_PACK", "operators": \[ { "id": "OP\_SIGMA\_INDEX", "symbol": "Σᵢ", "kind": "index\_summation", "signature": "Tensor(D\_i..., j, ...) × Index(i) \-\> Tensor(D\_..., j, ...)", "description": "Contract over a single index i, removing it from the free index set.", "constraints": \[ "Enforce SIGMA\_INV\_INDEX\_PRESERVATION", "Enforce SIGMA\_INV\_NULL\_MODE\_STABILITY" \] }, { "id": "OP\_SIGMA\_TENSOR", "symbol": "Σ⊗", "kind": "tensor\_contraction", "signature": "Tensor(D\_{i j ...}) × Metric(g^{i j}) \-\> Tensor(D\_{...})", "description": "General tensor contraction using an implicit or explicit metric or pairing tensor.", "constraints": \[ "Enforce SIGMA\_INV\_INDEX\_PRESERVATION", "Enforce SIGMA\_INV\_NULL\_MODE\_STABILITY" \] }, { "id": "OP\_SIGMA\_THETA", "symbol": "ΣΘ", "kind": "polarity\_aware\_summation", "signature": "Tensor(D\_{i}^{Θ}) \-\> Tensor(D^{Θ})", "description": "Σ contraction that routes through Θ channels. Each contracted index keeps polarity-consistency.", "constraints": \[ "Enforce SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION", "Enforce SIGMA\_INV\_NULL\_MODE\_STABILITY" \] }, { "id": "OP\_SIGMA\_NULL\_FILTER", "symbol": "Σ₀", "kind": "null\_mode\_filter", "signature": "Tensor(D\_{i}) \-\> Tensor(D\_{i})", "description": "Projectively enforces Null-Mode Stability by zeroing numerically small or explicitly null-tagged modes.", "constraints": \[ "Enforce SIGMA\_INV\_NULL\_MODE\_STABILITY" \] }, // \------------------------------------------------------------------ // Invariant Checkers (Side-effect free predicates) // \------------------------------------------------------------------ { "id": "CHK\_SIGMA\_INDEX\_PRESERVATION", "kind": "invariant\_checker", "invariant": "SIGMA\_INV\_INDEX\_PRESERVATION", "signature": "ContractionPlan \-\> Bool", "description": "Returns true iff the contraction removes only paired indices and leaves remaining free indices unchanged." }, { "id": "CHK\_SIGMA\_POLARITY\_CONSISTENCY", "kind": "invariant\_checker", "invariant": "SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION", "signature": "ContractionPlan × ThetaLabels \-\> Bool", "description": "Returns true iff all contracted indices respect Θ routing without illegal channel mixing." }, { "id": "CHK\_SIGMA\_NULL\_MODE\_STABILITY", "kind": "invariant\_checker", "invariant": "SIGMA\_INV\_NULL\_MODE\_STABILITY", "signature": "TensorBefore × TensorAfter \-\> Bool", "description": "Returns true iff null modes before contraction remain null after contraction, absent explicit source terms." } \] }  
---

### 3\. tier\_07\_interaction\_table.json5

json5  
Copy code  
{ // \====================================================================== // TIER 07 — Σ INTERACTION TABLE (MINIMAL WORKING EXAMPLE) // Each row: how Σ composes with other families under invariants. // \====================================================================== "tier": 7, "family": "Sigma", "table\_id": "T07\_SIGMA\_INTERACTION\_TABLE", "entries": \[ { "id": "INT\_SIGMA\_DELTA", "lhs": "Σ ∘ δ", "description": "Summation after deviation.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)", "δ does not alter index set of contracted indices" \], "effect": "Apply δ to tensor components, then perform Σ. Result is NF\_SIGMA if no index violations.", "nf\_tag": "NF\_SIGMA" }, { "id": "INT\_DELTA\_SIGMA", "lhs": "δ ∘ Σ", "description": "Deviation after summation.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "effect": "Perform Σ to reduce indices, then apply δ to reduced object.", "commutativity": "May commute with Σ ∘ δ when δ acts linearly on summed index.", "nf\_tag": "NF\_SIGMA\_DELTA" }, { "id": "INT\_SIGMA\_THETA", "lhs": "ΣΘ ∘ Θ", "description": "Polarity-routed summation after Θ-routing.", "preconditions": \[ "CHK\_SIGMA\_POLARITY\_CONSISTENCY(plan, theta\_labels)" \], "effect": "Θ routes positive/negative channels; ΣΘ sums each channel separately.", "invariants\_enforced": \[ "SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION" \], "nf\_tag": "NF\_SIGMA\_THETA" }, { "id": "INT\_SIGMA\_PSI", "lhs": "Σ ∘ ψ", "description": "Summation over oscillatory modes.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "effect": "ψ distributes over indices; Σ contracts mode amplitudes.", "null\_mode\_behavior": "ψ-null modes remain null under Σ by SIGMA\_INV\_NULL\_MODE\_STABILITY.", "nf\_tag": "NF\_SIGMA\_PSI" }, { "id": "INT\_SIGMA\_TRIUNITY", "lhs": "Σ ∘ (δ, Φ, Π)", "description": "Tri-Unity+Σ contraction.", "preconditions": \[ "Tri-Unity invariants satisfied", "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)", "CHK\_SIGMA\_NULL\_MODE\_STABILITY(t\_before, t\_after)" \], "effect": "Σ contracts Tri-Unity tensors while preserving Tri-Unity closure.", "nf\_tag": "NF\_TRIUNITY\_SIGMA" } \] }  
---

### 4\. tier\_07\_axiom\_box.json5 (Sealed Axiom Box)

json5  
Copy code  
{ // \====================================================================== // TIER 07 — Σ SEALED AXIOM BOX // Contains the three core Σ-invariants as axioms. // \====================================================================== "tier": 7, "family": "Sigma", "box\_id": "T07\_SIGMA\_AXIOM\_BOX", "sealed": true, // Sealed: may not be modified by downstream tiers. "axioms": \[ { "id": "AX\_SIGMA\_INDEX\_PRESERVATION", "name": "Index-Preservation Axiom", "invariant\_ref": "SIGMA\_INV\_INDEX\_PRESERVATION", "schema\_dual\_column": { "standard\_formal": "Let T be a tensor with free index set F and contracted index pair set C. Any Σ-contraction over C must produce a tensor T' whose free index set F' satisfies F' \= F \\\\ C.", "igsoa\_formal": "For any Domain Tensor D with index set I \= F ∪ C and Σ-contraction plan P: Σ\_P(D) is defined only if P removes exactly the indices in C and preserves the order and multiplicity of F in the result." } }, { "id": "AX\_SIGMA\_POLARITY\_CONSISTENT\_CONTRACTION", "name": "Polarity-Consistent Contraction Axiom", "invariant\_ref": "SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION", "schema\_dual\_column": { "standard\_formal": "Let T carry polarity labels Θ ∈ {Θ+, Θ−, ...} on indices. A Σ-contraction over an index i is allowed only if the paired indices possess compatible polarity labels under the Θ-algebra.", "igsoa\_formal": "Given a tensor D with polarity annotation map p: I \-\> ΘChannel and contraction plan P, a ΣΘ-contraction is defined only when (i, j) ∈ P implies p(i) \~Θ p(j), where \~Θ is the Θ-compatibility relation." } }, { "id": "AX\_SIGMA\_NULL\_MODE\_STABILITY", "name": "Null-Mode Stability Axiom", "invariant\_ref": "SIGMA\_INV\_NULL\_MODE\_STABILITY", "schema\_dual\_column": { "standard\_formal": "If a component of a tensor is a null mode (semantic zero) before Σ, and no explicit source or renormalization term is applied, then its contribution remains null after Σ.", "igsoa\_formal": "For any tensor component D\_α with semantic label s(α) \= 0\_sem, and contraction plan P, Σ\_P(D)\_β has contribution 0\_sem from α unless a non-null source operator S is explicitly applied." } } \], "theorems": \[ { "id": "THM\_SIGMA\_NF\_EXISTENCE", "name": "Σ-Normal Form Existence Theorem", "statement": "For any finite contraction plan P that respects the Σ-axioms, there exists a unique Σ-normal form NF\_SIGMA such that no further invariant-restoring Σ-rewrite is applicable.", "depends\_on": \[ "AX\_SIGMA\_INDEX\_PRESERVATION", "AX\_SIGMA\_POLARITY\_CONSISTENT\_CONTRACTION", "AX\_SIGMA\_NULL\_MODE\_STABILITY" \], "proof\_sketch\_dual\_column": { "standard\_side": "Show termination via strictly decreasing measure (number of index violations \+ polarity violations \+ null-mode violations) and local confluence of Σ-rewrites.", "igsoa\_side": "Define a Box-level measure μ\_SIGMA over contraction plans. Each rewrite strictly decreases μ\_SIGMA, and overlap critical-pairs resolve via Θ-aware Σ rules, yielding unique NF\_SIGMA." } } \] }  
---

### 5\. tier\_07\_rewrite\_system.json5

Includes actual invariant-restoring rewrites plus a tiny concrete ψ/Θ example.  
json5  
Copy code  
{ // \====================================================================== // TIER 07 — Σ REWRITE SYSTEM // Enforces Σ-invariants and computes Σ-normal forms. // \====================================================================== "tier": 7, "family": "Sigma", "rewrite\_system\_id": "T07\_SIGMA\_REWRITE\_SYSTEM", "normal\_form\_tag": "NF\_SIGMA", "rules": \[ // \-------------------------------------------------------------- // R1: Index Preservation — illegal free-index removal // \-------------------------------------------------------------- { "id": "R\_SIGMA\_FIX\_INDEX\_REMOVAL", "priority": 10, "pattern": { "kind": "contraction\_plan", "violations": \["free\_index\_removed"\] }, "guard": "NOT CHK\_SIGMA\_INDEX\_PRESERVATION(plan)", "action": "Remove contraction steps that target unpaired free indices; restrict Σ to valid contracted pairs.", "result\_tag": "NF\_SIGMA\_PARTIAL", "comment": "If a contraction tries to remove a free index, we trim that step from the plan." }, // \-------------------------------------------------------------- // R2: Polarity-Consistency — illegal mixed-channel contraction // \-------------------------------------------------------------- { "id": "R\_SIGMA\_SPLIT\_POLARITY\_CHANNELS", "priority": 9, "pattern": { "kind": "contraction\_plan", "violations": \["mixed\_polarity\_channel"\] }, "guard": "NOT CHK\_SIGMA\_POLARITY\_CONSISTENCY(plan, theta\_labels)", "action": "Split contraction into channel-wise ΣΘ over Θ+ and Θ− separately; if mixing is unavoidable, insert an explicit Θ-bridge operator before Σ.", "result\_tag": "NF\_SIGMA\_THETA", "comment": "Σ cannot sum Θ+ with Θ− in the same step without a Θ-bridge." }, // \-------------------------------------------------------------- // R3: Null-Mode Stability — spurious nonzero from null modes // \-------------------------------------------------------------- { "id": "R\_SIGMA\_ZERO\_NULL\_MODES", "priority": 8, "pattern": { "kind": "tensor\_pair", "violations": \["null\_mode\_amplified"\] }, "guard": "NOT CHK\_SIGMA\_NULL\_MODE\_STABILITY(before, after)", "action": "Force resulting components derived solely from null modes to 0\_sem; tag as invariant-restored.", "result\_tag": "NF\_SIGMA\_NULL", "comment": "Summing pure null-modes may not generate non-null components." }, // \-------------------------------------------------------------- // R4: Combined δ–Φ–Π–ψ–Σ evolution repair (tiny example) // \-------------------------------------------------------------- { "id": "R\_SIGMA\_COMBINED\_CHAIN\_FIX", "priority": 5, "pattern": { "kind": "evolution\_chain", "chain": \["δ", "ψ", "Σ", "Θ", "Π"\] }, "guard": "CHAIN\_HAS\_SIGMA\_VIOLATIONS(chain\_state)", "action": "Insert R\_SIGMA\_FIX\_INDEX\_REMOVAL, R\_SIGMA\_SPLIT\_POLARITY\_CHANNELS, and R\_SIGMA\_ZERO\_NULL\_MODES as needed, then recompute Σ-step before Θ and Π evaluation.", "result\_tag": "NF\_SIGMA\_CHAIN", "comment": "Ensures complex chains obey Σ-invariants before logic/truth evaluation." } \], // \------------------------------------------------------------------ // Minimal Worked Example (ψ \+ Θ \+ Σ) // \------------------------------------------------------------------ "worked\_example": { "id": "EX\_SIGMA\_MINIMAL\_POLARITY\_CONTRACTION", "description": "A 2-mode ψ-oscillating tensor with Θ-polarity labels undergoes ΣΘ contraction and is repaired to NF\_SIGMA.", "tensor\_before": { "indices": \["i"\], "components": \[ { "i": 0, "value": "A", "psi\_mode": "ω0", "theta": "Θ+", "semantic": "s\_A" }, { "i": 1, "value": "-A", "psi\_mode": "ω0", "theta": "Θ−", "semantic": "s\_B" } \] }, "naive\_contraction\_plan": { "operator": "Σ", "indices\_to\_contract": \["i"\], "comment": "Naively sums all i regardless of Θ channel." }, "violation": "mixed\_polarity\_channel", "rewrite\_sequence": \[ "R\_SIGMA\_SPLIT\_POLARITY\_CHANNELS" \], "tensor\_after": { "operator": "ΣΘ", "channels": \[ { "theta": "Θ+", "result": { "indices": \[\], "value": "A", "semantic": "s\_A" } }, { "theta": "Θ−", "result": { "indices": \[\], "value": "-A", "semantic": "s\_B" } } \], "nf\_tag": "NF\_SIGMA\_THETA" } } }  
---

### 6\. tier\_07\_module\_pack.json5

This is the bundle your agent will load: it points to the other five files and exposes a small test suite.  
json  
Copy code  
{ // \====================================================================== // TIER 07 — Σ MODULE PACK // Aggregates metadata, operator pack, interaction table, axiom box, // and rewrite system into one loadable module. // \====================================================================== "tier": 7, "family": "Sigma", "module\_id": "T07\_SIGMA\_MODULE\_PACK", "components": { "metadata": "tier\_07\_metadata.json5", "operator\_pack": "tier\_07\_operator\_pack.json5", "interaction\_table": "tier\_07\_interaction\_table.json5", "axiom\_box": "tier\_07\_axiom\_box.json5", "rewrite\_system": "tier\_07\_rewrite\_system.json5" }, "exports": { "invariants": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "operators": \[ "OP\_SIGMA\_INDEX", "OP\_SIGMA\_TENSOR", "OP\_SIGMA\_THETA", "OP\_SIGMA\_NULL\_FILTER" \], "normal\_forms": \[ "NF\_SIGMA", "NF\_SIGMA\_THETA", "NF\_SIGMA\_NULL", "NF\_SIGMA\_CHAIN" \] }, // \------------------------------------------------------------------ // Tiny regression tests for the Σ tier // \------------------------------------------------------------------ "regression\_tests": \[ { "id": "TEST\_SIGMA\_INDEX\_OK", "description": "Valid index contraction over paired indices only.", "input": { "tensor": "D\_{i j}", "plan": { "operator": "Σᵢ", "indices\_to\_contract": \["i"\] } }, "expected": { "nf\_tag": "NF\_SIGMA", "free\_indices\_after": \["j"\], "invariants\_ok": true } }, { "id": "TEST\_SIGMA\_INDEX\_VIOLATION", "description": "Attempt to contract a free index without a valid pair.", "input": { "tensor": "D\_{i}", "plan": { "operator": "Σ", "indices\_to\_contract": \["j"\] } }, "expected": { "applied\_rules": \["R\_SIGMA\_FIX\_INDEX\_REMOVAL"\], "invariants\_ok": true, "nf\_tag": "NF\_SIGMA\_PARTIAL" } }, { "id": "TEST\_SIGMA\_POLARITY\_VIOLATION", "description": "Naive Σ over mixed Θ channels gets rewritten to channel-wise ΣΘ.", "input": "EX\_SIGMA\_MINIMAL\_POLARITY\_CONTRACTION.tensor\_before", "plan": "EX\_SIGMA\_MINIMAL\_POLARITY\_CONTRACTION.naive\_contraction\_plan", "expected": { "applied\_rules": \["R\_SIGMA\_SPLIT\_POLARITY\_CHANNELS"\], "nf\_tag": "NF\_SIGMA\_THETA" } }, { "id": "TEST\_SIGMA\_NULL\_MODE", "description": "Null-mode components remain null after contraction.", "input": { "tensor": { "indices": \["i"\], "components": \[ { "i": 0, "value": 0, "semantic": "0\_sem" }, { "i": 1, "value": 0, "semantic": "0\_sem" } \] }, "plan": { "operator": "Σᵢ", "indices\_to\_contract": \["i"\] } }, "expected": { "applied\_rules": \["R\_SIGMA\_ZERO\_NULL\_MODES"\], "result\_component\_semantic": "0\_sem", "nf\_tag": "NF\_SIGMA\_NULL" } } \] }  
---

---

### tier\_07\_interaction\_table.json5 (extended grid)

json5  
Copy code  
{ // \====================================================================== // TIER 07 — Σ INTERACTION TABLE (EXTENDED GRID) // Full Σ × (δ, Φ, Π, ψ, Θ) grid with left/right compositions. // \====================================================================== "tier": 7, "family": "Sigma", "table\_id": "T07\_SIGMA\_INTERACTION\_TABLE\_EXTENDED", // Grid metadata: Σ vs other operator families "grid\_axes": { "sigma\_axis": "Σ", "other\_axis": \["δ", "Φ", "Π", "ψ", "Θ"\], "composition\_kinds": \["SigmaLeft", "SigmaRight"\] }, // \---------------------------------------------------------------------- // ENTRIES // Each entry describes a canonical composition, its preconditions, // invariants enforced, and resulting NF tag. // \---------------------------------------------------------------------- "entries": \[ // \============================================================== // 1\) Σ × δ: deviation \+ contraction // \============================================================== { "id": "INT\_SIGMA\_DELTA\_LEFT", "sigma\_side": "left", "other\_family": "δ", "lhs": "Σ ∘ δ", "canonical\_order": "δ first, then Σ", "description": "Deviation modifies components or geometry, then Σ contracts indices.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)", "δ does not change the count of indices destined for contraction" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "tensor", "index\_behavior": "Σ removes only contraction indices; free indices preserved.", "null\_mode\_behavior": "δ-linear shifts of null modes remain null if δ is purely linear." }, "nf\_tag": "NF\_SIGMA\_DELTA", "notes": "Standard case when δ is linear in contracted components; often commutes with δ ∘ Σ up to NF." }, { "id": "INT\_SIGMA\_DELTA\_RIGHT", "sigma\_side": "right", "other\_family": "δ", "lhs": "δ ∘ Σ", "canonical\_order": "Σ first, then δ", "description": "Contraction produces reduced tensor; δ acts on the reduced object.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "tensor", "index\_behavior": "Σ produces a tensor with fewer indices; δ acts on this new index set.", "null\_mode\_behavior": "If δ preserves null modes, Σ and δ commute up to NF\_SIGMA\_DELTA." }, "nf\_tag": "NF\_DELTA\_SIGMA", "commutativity": "When δ is linear and index-preserving, Σ ∘ δ ≈ δ ∘ Σ (mod NF\_SIGMA\_DELTA)." }, // \============================================================== // 2\) Σ × Φ: projection \+ contraction // \============================================================== { "id": "INT\_SIGMA\_PHI\_LEFT", "sigma\_side": "left", "other\_family": "Φ", "lhs": "Σ ∘ Φ", "canonical\_order": "Φ first, then Σ", "description": "Semantic projection refines classes, then Σ contracts within the projected semantic domain.", "preconditions": \[ "Φ satisfies Class Preservation Invariant", "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "tensor", "semantic\_behavior": "Indices are summed only within well-defined Φ-classes.", "null\_mode\_behavior": "Semantic classes projected to semantic-zero remain null under Σ." }, "nf\_tag": "NF\_SIGMA\_PHI", "notes": "Recommended canonical order for semantic-tensor contractions: project, then contract." }, { "id": "INT\_SIGMA\_PHI\_RIGHT", "sigma\_side": "right", "other\_family": "Φ", "lhs": "Φ ∘ Σ", "canonical\_order": "Σ first, then Φ", "description": "Σ contracts raw domain indices, then Φ projects the resulting object into semantic classes.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "tensor\_or\_scalar", "semantic\_behavior": "Φ acts on already contracted components; some semantic information may be lost." }, "nf\_tag": "NF\_PHI\_SIGMA", "commutativity": "Generally non-commutative with Σ ∘ Φ; NF equivalence only in special linear-class cases." }, // \============================================================== // 3\) Σ × Π: evaluation \+ contraction // \============================================================== { "id": "INT\_SIGMA\_PI\_LEFT", "sigma\_side": "left", "other\_family": "Π", "lhs": "Σ ∘ Π", "canonical\_order": "Π first, then Σ", "description": "Truth/evaluation map Π is applied component-wise, then Σ contracts evaluated values.", "preconditions": \[ "Projection–Evaluation Consistency (Φ → Π) holds upstream", "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "scalar\_or\_tensor", "truth\_behavior": "Π-values are summed; indices encode aggregation structure over truth valuations.", "null\_mode\_behavior": "Evaluations that yield null/0\_sem remain null under Σ." }, "nf\_tag": "NF\_SIGMA\_PI", "notes": "Useful when defining global truth-aggregates or energy-like scalar functionals." }, { "id": "INT\_SIGMA\_PI\_RIGHT", "sigma\_side": "right", "other\_family": "Π", "lhs": "Π ∘ Σ", "canonical\_order": "Σ first, then Π", "description": "Σ collapses structure into a smaller tensor/scalar, which Π then evaluates.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "scalar", "truth\_behavior": "Π evaluates a global contracted quantity (e.g., global consistency score)." }, "nf\_tag": "NF\_PI\_SIGMA", "commutativity": "Non-commutative in general; Π ∘ Σ often defines a coarser truth functional than Σ ∘ Π." }, // \============================================================== // 4\) Σ × ψ: oscillation \+ contraction // \============================================================== { "id": "INT\_SIGMA\_PSI\_LEFT", "sigma\_side": "left", "other\_family": "ψ", "lhs": "Σ ∘ ψ", "canonical\_order": "ψ first, then Σ", "description": "Wave/oscillation ψ acts on each component; Σ then contracts over indices or modes.", "preconditions": \[ "ψ distributes linearly over indices", "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "tensor\_or\_scalar", "wave\_behavior": "Mode amplitudes are summed; phase relationships enter through ψ before contraction.", "null\_mode\_behavior": "Pure ψ-null modes remain null under Σ." }, "nf\_tag": "NF\_SIGMA\_PSI", "notes": "This is the canonical ‘sum over modes’ picture used by the Semantic Wave Equation." }, { "id": "INT\_SIGMA\_PSI\_RIGHT", "sigma\_side": "right", "other\_family": "ψ", "lhs": "ψ ∘ Σ", "canonical\_order": "Σ first, then ψ", "description": "Indices are contracted first; ψ then acts on the contracted object.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "tensor\_or\_scalar", "wave\_behavior": "Oscillation is defined on aggregate quantities (e.g. global amplitude)." }, "nf\_tag": "NF\_PSI\_SIGMA", "commutativity": "Often ψ ∘ Σ and Σ ∘ ψ agree for linear ψ; differ when ψ couples indices/modes nontrivially." }, // \============================================================== // 5\) Σ × Θ: polarity router \+ contraction // \============================================================== { "id": "INT\_SIGMA\_THETA\_LEFT", "sigma\_side": "left", "other\_family": "Θ", "lhs": "ΣΘ ∘ Θ", "canonical\_order": "Θ first, then ΣΘ", "description": "Θ routes indices into polarity channels; ΣΘ contracts within each Θ-channel.", "preconditions": \[ "Θ routing is total on the indices to be contracted", "CHK\_SIGMA\_POLARITY\_CONSISTENCY(plan, theta\_labels)" \], "invariants\_enforced": \[ "SIGMA\_INV\_POLARITY\_CONSISTENT\_CONTRACTION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "polarity\_tensor\_or\_pair", "polarity\_behavior": "Separate Σ over Θ+ and Θ− channels; no cross-channel mixing.", "null\_mode\_behavior": "Polarity-specific null modes remain null under ΣΘ." }, "nf\_tag": "NF\_SIGMA\_THETA", "notes": "This is the canonical Θ-aware summation; used by Θ-layer logic gate definitions." }, { "id": "INT\_SIGMA\_THETA\_RIGHT", "sigma\_side": "right", "other\_family": "Θ", "lhs": "Θ ∘ Σ", "canonical\_order": "Σ first, then Θ", "description": "Σ contracts first, producing a smaller tensor; Θ then assigns or updates polarity channels on the result.", "preconditions": \[ "CHK\_SIGMA\_INDEX\_PRESERVATION(plan)" \], "invariants\_enforced": \[ "SIGMA\_INV\_INDEX\_PRESERVATION", "SIGMA\_INV\_NULL\_MODE\_STABILITY" \], "effect": { "type": "polarity\_tensor", "polarity\_behavior": "Θ labels the contracted result; polarity assignment may hide channel-wise cancellation details." }, "nf\_tag": "NF\_THETA\_SIGMA", "commutativity": "Non-commutative: Θ ∘ Σ generally does not preserve the ΣΘ channel-wise structure of ΣΘ ∘ Θ." } \], // \---------------------------------------------------------------------- // GRID VIEW (for your agent / UI) // This is a purely structural index over the entries above so a VM // can quickly dispatch on (sigma\_side, other\_family). // \---------------------------------------------------------------------- "grid\_index": { "SigmaLeft": { "δ": "INT\_SIGMA\_DELTA\_LEFT", "Φ": "INT\_SIGMA\_PHI\_LEFT", "Π": "INT\_SIGMA\_PI\_LEFT", "ψ": "INT\_SIGMA\_PSI\_LEFT", "Θ": "INT\_SIGMA\_THETA\_LEFT" }, "SigmaRight": { "δ": "INT\_SIGMA\_DELTA\_RIGHT", "Φ": "INT\_SIGMA\_PHI\_RIGHT", "Π": "INT\_SIGMA\_PI\_RIGHT", "ψ": "INT\_SIGMA\_PSI\_RIGHT", "Θ": "INT\_SIGMA\_THETA\_RIGHT" } } }

