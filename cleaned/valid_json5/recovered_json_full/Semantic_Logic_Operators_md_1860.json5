{ "theta\_and": "function theta\_and(tA, tB): return (tA \== 'Θ+' and tB \== 'Θ+') ? 'Θ+' : 'Θ-';", "theta\_or": "function theta\_or(tA, tB): return (tA \== 'Θ+' or tB \== 'Θ+') ? 'Θ+' : 'Θ-';", "theta\_not": "function theta\_not(tA): return (tA \== 'Θ+') ? 'Θ-' : 'Θ+';", "sigma\_and": "function sigma\_and(sA, sB): return min(sA, sB);", "sigma\_or": "function sigma\_or(sA, sB): return max(sA, sB);", "sigma\_not": "function sigma\_not(sA): return 1.0 \- sA;", "pi\_and": "function pi\_and(pA, pB): return min(pA, pB);", "pi\_or": "function pi\_or(pA, pB): return max(pA, pB);", "pi\_not": "function pi\_not(pA): return 1 \- pA;", "sigma\_quant\_forall": "function sigma\_quant\_forall({s\_x}): return infimum of s\_x over domain;", "sigma\_quant\_exists": "function sigma\_quant\_exists({s\_x}): return supremum of s\_x over domain;", "pi\_quant\_forall": "function pi\_quant\_forall({p\_x}): return (forall x: p\_x \== 1\) ? 1 : 0;", "pi\_quant\_exists": "function pi\_quant\_exists({p\_x}): return (exists x: p\_x \== 1\) ? 1 : 0;", "sigma\_modal\_necessity": "function sigma\_modal\_necessity({s\_w}): return infimum of s\_w over admissible worlds;", "sigma\_modal\_possibility": "function sigma\_modal\_possibility({s\_w}): return supremum of s\_w over admissible worlds;", "pi\_modal\_necessity": "function pi\_modal\_necessity({p\_w}): return (forall w: p\_w \== 1\) ? 1 : 0;", "pi\_modal\_possibility": "function pi\_modal\_possibility({p\_w}): return (exists w: p\_w \== 1\) ? 1 : 0;" }