{ // \======================================================================== // TIER 02 — Φ REWRITE SYSTEM (ENFORCING INVARIANTS) // \======================================================================== meta: { tier: 2, family: "Φ", module: "tier\_02\_rewrite\_system", version: "0.1.0", }, // Patterns are schematic; your agent can refine them into concrete rule engines. rules: \[ // \--------------------------------------------------------- // R1: Class Preservation Repair // \--------------------------------------------------------- { id: "PHI\_RW\_01\_CLASS\_REPAIR", target\_invariant: "PHI\_INV\_01\_CLASS\_PRESERVATION", pattern: "B \-\> Φ(B)", precondition: "C(B) ≠ ⊥ ∧ C(Φ(B)) \= ⊥", action: \` SUBSTITUTE C(Φ(B)) with nearest-valid class in lattice L\_semantic\_classes or flag Box as INVALID\_CLASS\_ERROR if no such class exists. \`, ensures: "C(Φ(B')) ≠ ⊥", notes: "B' is the repaired Box after class re-alignment.", }, // \--------------------------------------------------------- // R2: Project-Then-Eval Normalization // \--------------------------------------------------------- { id: "PHI\_RW\_02\_PHI\_PI\_NF", target\_invariant: "PHI\_INV\_02\_PROJ\_EVAL\_CONSISTENCY", pattern: "Π(Φ(B))", precondition: "Π(B) defined ∧ Π(Φ(B)) defined", action: \` REWRITE Π(Φ(B)) \=\> NF(Π(B)) // agent computes Π(B), then normalizes to canonical truth NF. \`, ensures: "NF(Π(Φ(B))) \= NF(Π(B))", }, // \--------------------------------------------------------- // R3: Illegal Φ-Projection Guard // \--------------------------------------------------------- { id: "PHI\_RW\_03\_ILLEGAL\_PHI", target\_invariant: "PHI\_INV\_01\_CLASS\_PRESERVATION", pattern: "Φ(B)", precondition: "C(B) \= ⊥", action: \` REWRITE Φ(B) \=\> ⊥\_PhiDomain // Φ is undefined on Boxes without valid semantic class. \`, ensures: "Domain error is explicit and not silently propagated.", }, // \--------------------------------------------------------- // R4: Φ–δ Commutation on Stable Classes // \--------------------------------------------------------- { id: "PHI\_RW\_04\_DELTA\_PHI\_COMMUTE", target\_invariant: "PHI\_INV\_01\_CLASS\_PRESERVATION", pattern: "δ(Φ(B))", precondition: "δ preserves C(B) and Φ is defined on B and δ(B)", action: \` REWRITE δ(Φ(B)) \=\> Φ(δ(B)) // enforce commutation where class-preserving δ makes it safe. \`, ensures: "Semantic class remains consistent along δ–Φ path.", }, \], }