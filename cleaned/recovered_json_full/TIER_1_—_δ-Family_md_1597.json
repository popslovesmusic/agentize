{ "tier": 10, "rewrite\_rules": \[ { "pattern": "Ω\_constraint(a)", "rewrite": "Ω(a)", "description": "Treat Ω\_constraint as application of the Ω projector." }, { "pattern": "Ω\_norm(Ω(a))", "rewrite": "Ω\_norm(a)", "description": "Norm after projection equals norm of constrained component." }, { "pattern": "χ∘Ω", "rewrite": "Ω∘χ (on S\_Ω)", "description": "On the constraint surface, χ evolution commutes with Ω." }, { "pattern": "d/dχ Ω\_norm(a(χ))", "rewrite": "0 (for Ω-consistent evolution)", "description": "Invariants remain constant along Ω-consistent flows." }, { "pattern": "Ωχ\_H ↔ Ωχ\_L", "rewrite": "Hamiltonian\_Lagrangian\_pair", "description": "Relate Ωχ\_H and Ωχ\_L via Legendre transform when possible." }, { "pattern": "Ω∘Σ", "rewrite": "Σ∘Ω (on S\_Ω)", "description": "Contractions and constraints can be interchanged on constrained states." }, { "pattern": "Ω∘ψ", "rewrite": "ψ\_constrained\_spectrum", "description": "Restrict ψ to globally allowed mode spectrum." } \], "normal\_form\_rules": \[ "Always project arbitrary states with Ω before evaluating global norms or invariants.", "Rewrite any χ evolution of Ω-constrained states so that Ω is applied first, then χ (Ω∘χ).", "Express conservation statements as d/dχ Ω\_norm(...) \= 0.", "When both Hamiltonian and Lagrangian forms exist, choose one canonical representation (usually Ωχ\_H for evolution equations, Ωχ\_L for variational principles).", "Simplify any Ω∘Σ or Σ∘Ω compositions by using the commutation rule on constrained states.", "Canonical high-level order: (local ops δ,Φ,Π,μ,λ,ψ,Σ,Θ) → χ → Ω (final constraint and normalization)." \] }