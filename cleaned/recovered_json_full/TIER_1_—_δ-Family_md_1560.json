{ "tier": 5, "rewrite\_rules": \[ { "pattern": "λ \= ?", "rewrite": "λ\_curv \+ λ\_mode \+ λ\_x", "description": "Decompose λ into pure curvature, mode deformation, and cross-mode curvature components." }, { "pattern": "λ∘δ \- δ∘λ", "rewrite": "\[λ, δ\]", "description": "Express curvature-induced deviation as the λ–δ commutator." }, { "pattern": "λ∘ψ \- ψ∘λ", "rewrite": "\[λ, ψ\]", "description": "Express mode-deformation and frequency shift as the λ–ψ commutator." }, { "pattern": "CurvatureConfig → DeviationOperator", "rewrite": "λ→δ(CurvatureConfig)", "description": "Map curvature data to an induced effective δ-like operator." }, { "pattern": "λ∘(δ, Φ, Π)", "rewrite": "(λδ, λΦ, λΠ)", "description": "Lift the Tri-Unity into its curved counterpart." }, { "pattern": "λ∘μ", "rewrite": "μ-weighted\_curvature", "description": "Fold local weight into curvature when possible." } \], "normal\_form\_rules": \[ "First decompose λ into (λ\_curv, λ\_mode, λ\_x) before further simplification.", "Represent curvature effects using commutators \[λ, δ\], \[λ, ψ\], etc., rather than expanded expressions when possible.", "When both μ and λ appear, rewrite expressions into μ-weighted curvature form (e.g., μ λ\_curv) before applying δ.", "For Tri-Unity expressions, rewrite flat operators (δ,Φ,Π) and their curved copies (λδ,λΦ,λΠ) into a canonical cube layout.", "Order of simplification: decompose λ → compute commutators → express induced δ via λ→δ → push to Tri-Unity+λ cube form." \] }